import 'dart:async';

import '../../relic.dart';

/// A function which creates a new [Handler] by wrapping a [Handler].
///
/// You can extend the functions of a [Handler] by wrapping it in
/// [Middleware] that can intercept and process a request before it it sent
/// to a handler, a response after it is sent by a handler, or both.
///
/// Because [Middleware] consumes a [Handler] and returns a new
/// [Handler], multiple [Middleware] instances can be composed
/// together to offer rich functionality.
///
/// Common uses for middleware include caching, logging, and authentication.
///
/// Middleware that captures exceptions should be sure to pass
/// [HijackException]s on without modification.
///
/// A simple [Middleware] can be created using [createMiddleware].
typedef Middleware = Handler Function(Handler innerHandler);

/// Creates a [Middleware] using the provided functions.
///
/// If provided, [onRequest] receives a [Request]. It can respond to
/// the request by returning a [Response] or [Future<Response>].
/// [onRequest] can also return `null` for some or all requests in which
/// case the request is sent to the inner [Handler].
///
/// If provided, [onResponse] is called with the [Response] generated
/// by the inner [Handler]. Responses generated by [onRequest] are not
/// sent to [onResponse].
///
/// [onResponse] should return either a [Response] or
/// [Future<Response>]. It may return the response parameter it receives or
/// create a new response object.
///
/// If provided, [onError] receives errors thrown by the inner handler. It
/// does not receive errors thrown by [onRequest] or [onResponse], nor
/// does it receive [HijackException]s. It can either return a new response or
/// throw an error.
Middleware createMiddleware({
  FutureOr<Response?> Function(Request)? onRequest,
  FutureOr<Response> Function(Response)? onResponse,
  final FutureOr<Response> Function(Object error, StackTrace)? onError,
}) {
  onRequest ??= (final request) => null;
  onResponse ??= (final response) => response;

  return (final innerHandler) {
    return (final ctx) async {
      var response = await onRequest!(ctx.request);
      if (response != null) return ctx.respond(response);
      late ResponseContext responseCtx;
      try {
        final newCtx = await innerHandler(ctx);
        if (newCtx is! ResponseContext) return newCtx;
        responseCtx = newCtx;
      } catch (e, s) {
        if (onError != null) {
          return ctx.respond(await onError(e, s));
        }
        rethrow;
      }
      response = await onResponse!(responseCtx.response);
      return responseCtx.respond(response);
    };
  };
}

/// An abstract base class for classes that behave like [Middleware].
///
/// Instances of [MiddlewareObject] are callable as [Middleware], and
/// can be passed as middleware via a [call] tear-off.
///
/// Overriding [call] is mandatory.
///
/// If the middleware requires special path parameters, then you should
/// override [injectIn].
abstract class MiddlewareObject implements RouterInjectable {
  /// Use this middleware on [router] on path `/`.
  /// Override to use on a different path.
  @override
  void injectIn(final Router<Handler> router) => router.use('/', call);

  /// The implementation of this [MiddlewareObject]
  Handler call(final Handler next);

  /// Returns this [MiddlewareObject] as a [Middleware] function.
  Middleware get asMiddleware => call;

  const MiddlewareObject();
}
