import 'dart:async';

import '../../relic.dart';

/// A function which creates a new [Handler] by wrapping a [Handler].
///
/// You can extend the functions of a [Handler] by wrapping it in
/// [Middleware] that can intercept and process a request before it is sent
/// to a handler, a response after it is sent by a handler, or both.
///
/// Because [Middleware] consumes a [Handler] and returns a new
/// [Handler], multiple [Middleware] instances can be composed
/// together to offer rich functionality.
///
/// Common uses for middleware include caching, logging, and authentication.
///
/// Middleware that captures exceptions should be sure to pass
/// [HijackException]s on without modification.
///
/// A simple [Middleware] can be created using [createMiddleware].
///
/// ## Basic Middleware
///
/// ```dart
/// Middleware loggingMiddleware = (Handler innerHandler) {
///   return (NewContext ctx) async {
///     print('Request: ${ctx.request.method} ${ctx.request.url}');
///     final result = await innerHandler(ctx);
///     print('Completed request');
///     return result;
///   };
/// };
/// ```
///
/// ## Using createMiddleware
///
/// ```dart
/// // Request processing
/// final middleware = createMiddleware(
///   onRequest: (request) {
///     print('Processing: ${request.url}');
///     return null; // Continue to handler
///   },
/// );
///
/// // Response processing
/// final middleware = createMiddleware(
///   onResponse: (response) {
///     print('Status: ${response.statusCode}');
///     return response;
///   },
/// );
///
/// // Error handling
/// final middleware = createMiddleware(
///   onError: (error, stackTrace) {
///     print('Error: $error');
///     return Response.internalServerError(
///       body: Body.fromString('An error occurred'),
///     );
///   },
/// );
/// ```
///
/// ## Authentication Middleware
///
/// ```dart
/// final authMiddleware = createMiddleware(
///   onRequest: (request) {
///     final auth = request.headers.authorization;
///     if (auth == null) {
///       return Response.unauthorized(
///         body: Body.fromString('Authentication required'),
///       );
///     }
///     return null; // Continue to handler
///   },
/// );
/// ```
typedef Middleware = Handler Function(Handler innerHandler);

/// Creates a [Middleware] using the provided functions.
///
/// If provided, [onRequest] receives a [Request]. It can respond to
/// the request by returning a [Response] or [Future<Response>].
/// [onRequest] can also return `null` for some or all requests in which
/// case the request is sent to the inner [Handler].
///
/// If provided, [onResponse] is called with the [Response] generated
/// by the inner [Handler]. Responses generated by [onRequest] are not
/// sent to [onResponse].
///
/// [onResponse] should return either a [Response] or
/// [Future<Response>]. It may return the response parameter it receives or
/// create a new response object.
///
/// If provided, [onError] receives errors thrown by the inner handler. It
/// does not receive errors thrown by [onRequest] or [onResponse], nor
/// does it receive [HijackException]s. It can either return a new response or
/// throw an error.
///
/// ## Examples
///
/// ```dart
/// // Logging middleware
/// final logger = createMiddleware(
///   onRequest: (request) {
///     print('${request.method} ${request.url}');
///     return null;
///   },
///   onResponse: (response) {
///     print('Response: ${response.statusCode}');
///     return response;
///   },
/// );
///
/// // CORS middleware
/// final cors = createMiddleware(
///   onResponse: (response) {
///     return response.copyWith(
///       headers: response.headers.transform((h) {
///         h['Access-Control-Allow-Origin'] = ['*'];
///       }),
///     );
///   },
/// );
///
/// // Error handling middleware
/// final errorHandler = createMiddleware(
///   onError: (error, stackTrace) {
///     print('Error: $error');
///     return Response.internalServerError(
///       body: Body.fromString('Server error'),
///     );
///   },
/// );
/// ```
Middleware createMiddleware({
  FutureOr<Response?> Function(Request)? onRequest,
  FutureOr<Response> Function(Response)? onResponse,
  final FutureOr<Response> Function(Object error, StackTrace)? onError,
}) {
  onRequest ??= (final request) => null;
  onResponse ??= (final response) => response;

  return (final innerHandler) {
    return (final ctx) async {
      var response = await onRequest!(ctx.request);
      if (response != null) return ctx.respond(response);
      late ResponseContext responseCtx;
      try {
        final newCtx = await innerHandler(ctx);
        if (newCtx is! ResponseContext) return newCtx;
        responseCtx = newCtx;
      } catch (e, s) {
        if (onError != null) {
          return ctx.respond(await onError(e, s));
        }
        rethrow;
      }
      response = await onResponse!(responseCtx.response);
      return responseCtx.respond(response);
    };
  };
}

/// An abstract base class for classes that behave like [Middleware].
///
/// Instances of [MiddlewareObject] are callable as [Middleware], and
/// can be passed as middleware via a [call] tear-off.
///
/// Overriding [call] is mandatory.
///
/// If the middleware requires special path parameters, then you should
/// override [injectIn].
abstract class MiddlewareObject implements RouterInjectable {
  /// Use this middleware on [router] on path `/`.
  /// Override to use on a different path.
  @override
  void injectIn(final Router<Handler> router) => router.use('/', call);

  /// The implementation of this [MiddlewareObject]
  Handler call(final Handler next);

  /// Returns this [MiddlewareObject] as a [Middleware] function.
  Middleware get asMiddleware => call;

  const MiddlewareObject();
}
