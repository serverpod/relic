import 'dart:async';

import '../adapter/context.dart';
import '../handler/handler.dart';
import '../message/request.dart';
import '../message/response.dart';

/// A function which creates a new [Handler] by wrapping a [Handler].
///
/// You can extend the functions of a [Handler] by wrapping it in
/// [Middleware] that can intercept and process a request before it it sent
/// to a handler, a response after it is sent by a handler, or both.
///
/// Because [Middleware] consumes a [Handler] and returns a new
/// [Handler], multiple [Middleware] instances can be composed
/// together to offer rich functionality.
///
/// Common uses for middleware include caching, logging, and authentication.
///
/// Middleware that captures exceptions should be sure to pass
/// [HijackException]s on without modification.
///
/// A simple [Middleware] can be created using [createMiddleware].
typedef Middleware = Handler Function(Handler innerHandler);

/// Creates a [Middleware] using the provided functions.
///
/// If provided, [onRequest] receives a [Request]. It can respond to
/// the request by returning a [Response] or [Future<Response>].
/// [onRequest] can also return `null` for some or all requests in which
/// case the request is sent to the inner [Handler].
///
/// If provided, [onResponse] is called with the [Response] generated
/// by the inner [Handler]. Responses generated by [onRequest] are not
/// sent to [onResponse].
///
/// [onResponse] should return either a [Response] or
/// [Future<Response>]. It may return the response parameter it receives or
/// create a new response object.
///
/// If provided, [onError] receives errors thrown by the inner handler. It
/// does not receive errors thrown by [onRequest] or [onResponse], nor
/// does it receive [HijackException]s. It can either return a new response or
/// throw an error.
Middleware createMiddleware({
  FutureOr<Response?> Function(Request)? onRequest,
  FutureOr<Response> Function(Response)? onResponse,
  final FutureOr<Response> Function(Object error, StackTrace)? onError,
}) {
  onRequest ??= (final request) => null;
  onResponse ??= (final response) => response;

  return (final innerHandler) {
    return (final requestCtx) async {
      if (requestCtx is! RespondableContext) return requestCtx;
      final ctx = requestCtx as RespondableContext; // why is this needed
      var response = await onRequest!(ctx.request);
      if (response != null) return ctx.withResponse(response);
      late ResponseContext responseCtx;
      try {
        final newCtx = await innerHandler(requestCtx);
        if (newCtx is! ResponseContext) return newCtx;
        responseCtx = newCtx;
      } catch (e, s) {
        if (onError != null) {
          return ctx.withResponse(await onError(e, s));
        }
        rethrow;
      }
      response = await onResponse!(responseCtx.response);
      return responseCtx.withResponse(response);
    };
  };
}
